---
title: Java-送分题之Map
date: 2019-05-17 23:35:03
tags: [Java, 送分题]
categories: Code
toc: true
---



Map的一些相关问题可以说是面试官最喜欢的问题了. 那么我们就系统性的说说这个问题

### 常用实现类

* HashTable
* HashMap
* WeakHashMap
* LinkedHashMap
* ConcurrentHashMap
* TreeMap

<!-- more -->
### 特点及使用目的

* HashTable
    线程安全, 目前基本已经舍弃不使用
* HashMap
    线程不安全, 大量使用, 存储速度快, 查找速度快,常用于线程安全的线程中做中间变量
* WeakHashMap
    继承以上HashMap的所有优缺点, 多了一个特性: ***其KV对象Entry,会在其Key中只有Map本身引用的时候进行删除***
* LinkedHashMap
    基于HashMap进行数据存储实现, 并在每个元素中加入了链表属性来维持其元素的顺序性
* ConcurrentHashMap
    基于HashMap存储结构, 保证了线程安全
* TreeMap
    基于红黑树实现的Map, 并且有序

### 实现方式

由于TreeMap的实现方式比较特殊, 所以我们先从`Hash`开始讲起

#### 1. Map depend on `hash`

首先我们要理解一下`Map`是什么, Map在这里的意思不是说地图, 指的是映射. 众所周知, Map是KV键值对, Map里面主要解决的就是如何将K正确的指向V
在我们的日常操作中的数据都是杂乱无章的, 甚至是没有规则的, 那么通过一定的方式将无章法的, 无规则的东西变成和章法,在一定范围或者规则内, 且便于操作的目标或者值, 这个过程就叫`hash`

比如我们常说的对数字取模.
> 我们有无穷多个数, 但是通过对某个数字n取模, 我们就会得到固定范围的0~n-1的数字.

> 所以, 对于数据分布足够宽, 足够平均分布的时候, 我们利用Hash实现的Map会得到最高性能的查询.

如果有疑问, 往下面看:
在所有数据结构中, 我们知道在已知下标的情况下, 数组的查询速度是最快的. 复杂度为O(1)
那么先定个目标, 我们采用数组来实现KV Map
![图1](1.png)

那么问题来了: ***如何使得K能直接查找到V, 也就是如何通过Key来对应到其对应值的下标呢?***
![图2](2.png)

假设我们的Key都是整数, 那么我们此时,数组长度为7, 那么为了得到一个0~6范围内的正整数, 我们对key进行一个hash, 即:
> hash = k % 7
那么此时我们通过hash值就可以得到其对应位置, 并将数值存入到对应的数组位置当中

![图3](3.png)
到这一步, 我们基于Hash的Map已经形成雏形

但是又一个新的问题诞生了:***此时如果再来一个新元素K8 V8 如何插入?***
此处我们默认K8的值等于7. 那么按照我们之前的hash规则, 则会得到hash=0, 但是下标为0的位置已经有元素V0 的存在, 此处产生了***hash冲突***, 即K不同,
但是取得的hash值是相同的
我们需要一个额外的方法来存储哈希冲突的问题,此处就引入一个数据结构`链表`, 将发生hash冲突的值和已经存在的值相关联
![图4](4.png)
问题又来了: ***值是放进去了, 但是如果我取得时候, 也是通过hash值来获取值, 我怎么知道取哪个呢?***
所以为了解决这个问题, 存的时候, 我们不仅要存储Value, 还要将Key给存储进去, 那么当遇到有链表的值得时候. 就遍历链表, 拿Key值去进行equals比较. 保证拿出
的值是正确的.
![图5](5.png)
到这一步. 基本上正确的存数据于取数据就没有问题了. 但是由此也因为hash冲突的问题诞生了另一个问题:
> 如果这样不停的塞值. 比如从0~100000, 这样每个链表就越来越长越来越长, 以至于当我们随机一个key取值得时候, 基本都是在遍历链表. 这样就已经让我们失去数组快速查找的优势了.
我们需要一个解决方案, 来解决hash冲突, 避免这样长链表的诞生. 从这里我们就开始讲Java的解决方案
首先, 想要hash数值足够宽. 那么对于前面的`k % length`这个公式, 我们势必就是要扩大分母, 也就是对数组进行扩容.
但是何时扩容?
Java引进了一个负载因子的概念`DEFAULT_LOAD_FACTOR`:

```java
static final float DEFAULT_LOAD_FACTOR = 0.75f;
```

> 当数组中存在元素个数的个数达到`数组长度*0.75f`的时候, 开始对数组进行扩容

但是若数组长度并没有达到负载因子的长度的时候, 发生了严重的hash冲突, 也势必会产生非常严重的哈希冲突导致遍历大链表的情况发生. 
于是针对于这种情况(JDK1.7 实现方式), 在JDK1.8中, 当链表元素达到8的时候, 则会将链表结构改成`红黑树`. 利用红黑树的自我平衡特点来加快元素的查找,
避免大链表的产生

> 关于红黑树的特性, 可以通过 [红黑树在线演示](https://www.cs.usfca.edu/~galles/visualization/RedBlack.html) 来了解其特性

正常状态下HashMap结构图
![图6](6.png)

那么每次扩容, 扩容多少呢. 在JDK1.8 中, 每次扩容的长度都固定是2的n次幂, 为什么选这个数呢?

> hash % $ 2^n $等价于 hash & $ 2^n - 1$(与运算)

补充:
> 与运算,和或运算一起无限接近于CPU实际运算的一种运算方式.
> 视为 0 为false 1为true.
> 4 % 2 = 0; 等价于 4 & 2-1
> 即(二进制) 1000 & 0001 = 0000
> 运算过程:
> 位数不足0补足, 对应位进行逻辑计算

所以, 利用这个特性, 加快运算, 从而选择了2的n次幂

但是由于HashMap并没有引入锁的机制, 所以是线程不安全的, 尤其发生在resize()也就是数组扩容的时候

***To Be Continue ....***

***

2019年5月21日更新:

`resize()`会出现什么问题呢?

首先我们来理清一下resize()做了哪些事情.

首先创建一个新的table[], 长度为 $2^n$.
然后遍历原有table[]上的元素, 并对其进行rehash, 将原有元素重新附着到新的table上.

exp
> 现我们有一个原始长度为2,且有数据存在的hashmap. 并且有两个线程A与B欲对其进行操作
![EXP](7.png)

