---
title: Nginx 高负载优化(转述自知乎, 笔记)
date: 2019-05-19 01:25:25
toc: true
tags: [后端, 高并发]
categories: Notes
---

出处: [知乎原文-Nginx百万优化](https://zhuanlan.zhihu.com/p/49415781)
此处为笔记向

### 1. 方法论

* 保持并发了连接数, 做到内存有效应用
* 高并发的同时保持高吞吐量

<!-- more -->
高并发问题分解
![问题分解](nginx.jpg)

优化从三个方面优化. 应用, 框架, 内核
![优化方向](nginx2.jpg)

### 2. 硬件

![硬件](nginx4.jpg)

### 3. 软件

![软件](nginx3.jpg)

### 4. 请求

    Nginx 模块结构
![Nginx模块](nginx5.jpg)

#### 4.1 请求到来

一个请求到来的时候,操作系统内核中有一个队列, 系统进程会对其进行调用. 由于有很多工作进程, 谁去调用是个问题. **负载均衡策略**

现在有一个时间模块, 调用了`epoll wait`接口, `accept`建立好一个新的连接, 这时会分配到连接内存池, 这个内存池会在连接刚创建的时候分配, 而当连接关闭的时候进行释放

连接进入之后, 接下来就来到了Nginx模块, 这时候会加一个`定时器`, 60s, 建立好连接后60s没有收到客户端的信息就自动关闭; 如果60s过来之后就去分配内存, 读缓冲区.

操作系统内核收到请求后, 但是用于应用程序是处理不聊的, 因为现在还只是存在內核态内存, 没有读取到用户态内存. 所以这时候要内存分配, 从连接内存池这里分配. 大概1K内存

![接受请求时间模块](nginx6.jpg)

#### 4.2 接受请求

当收到请求之后, 接受`url`和`header`, 分配请求内存池, 这时候 request pool size 是4K.这个和刚才有差不多8倍差距:

> 当请求特别长时, 就会分配更大的, 刚刚1K不够用了, 不会一次性分配32K, 而是一次性分配8K, 如果8K以后还是不能解析到刚才的标识符, 就会分配第二个8K.

之前收到的所有东西都不会释放, 只是放一个指针, 放到url或者指到协议, 标识它有多长即可.

接下来解决header, 这个流程一模一样的没有什么区别，这时候还会有一个不够用的情况，当我接收完所有的header以后，会把刚刚的定时器给移除，移除后接下来做11个阶段的处理，也就是说刚刚所有的外部服务器都是通过很多的模块串成在一起处理一个请求的。

![接收http请求模块](nginx7.jpg)

上图有个疑问: **11个阶段的http请求处理**

> 刚刚读完header需要处理, 所以这时候第一阶段是`post-read`. 接下来会有`rewrite`, 还有`access`和`preaccess`

![11阶段](nginx8.jpg)

### 5. 应用层优化

#### 5.1 协议

做应用层的优化先看协议层有什么可以优化的, 比如说编码方式, header每次都会去传用Nginx的架构,以至于浪费了很多的流量, 我们可以改善http2, 有很多这样的协议会大幅度提升它的性能

而如果你改善HTTP2, 则会带来其他问题, 比如http2必须走这条路. 这条路线又是一个很大的话题, 它涉及到安全性和性能, 是互相冲突的东西

![协议优化](nginx9.jpg)

#### 5.2 压缩

我们希望"商"越大越好, 压缩这里会有一个重点提出来的: 动态和静态. 比如我们用了拷贝, 比如说从磁盘中直接由内核来发给网卡, 但一旦压缩的话, 就不得不先把文件读到nginx, 交给后面的极内核去做一下处理.

keepalive长连接也是一样的, 涉及到很多东西, 简单来看也是复用连接. 因为连接有一个慢启动的过程, 一开始他的窗口是比较小, 一次可能只传送很小的1K, 但后面可能会传送几十K, 所以你每次新建连接它都会重新开始. 非常慢.
这里还涉及到一个问题, 因为nginx内核默认打开了一个连接空闲的时候, 长连接产生的作用也会下降.

#### 5.3 提高内存使用率

CPU通过缓存区来取出储存上东西的时候, 是一批一批取得, 每一批目前是64bytes, 所以默认的是8K, 如果你配了32, 会给你上升到64, 如果配了65 会上升到128, 因此它是一个一个序列化重组的, 所以了解这个东西以后再配的时候就不会再犯问题,.
![内存使用率](nginx10.jpg)

#### 5.4 限速

限流到底在限什么? 最主要限在Nginx向客户端发送响应的速度.
![限流](nginx11.jpg)

#### 5.5 Worker间负载均衡

![worker负载均衡](nginx12.jpg)

#### 5.6 超时

#### 5.7 缓存

#### 5.8 减少磁盘IO

优化读取，Sendfile零拷贝、内存盘、SSD盘。减少写入，AIO，磁盘是远大于内存的，当它把你内存消化完的时候还会退化成一个调用。像thread pool只用读文件，当退化成这种模式变多线程可以防止它的主进程被阻塞住，这时候官方的博客上说是有9倍的性能提升。

![减少磁盘IO](nginx13.jpg)

### 6. 系统优化