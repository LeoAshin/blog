---
title: '笔记: MysqlInnoDB 缓冲池详解'
date: 2019-05-22 16:32:56
tags: [Mysql]
categories: Code
---

InnoDB存储是基于磁盘存储的, 并且将其中记录按页的方式进行管理(InnoDB中数据最小单位是页)
为了弥补CPU与磁盘之间速度的鸿沟, 引入了缓冲池来提高数据写入的性能

<!-- more -->
### 缓冲池是一个什么样的存在

1. 当读取数据的时候, 首先将磁盘的读取到的数据页存储到缓冲池中. 这个过程叫"Fix"到缓冲池
当下一次再读取该页的时候, 判断是否在缓冲池中, 若缓存命中, 则直接读取该页, 否则读取磁盘

2. 当对数据库中的页进行修改的时候, 首先修改在缓冲池的页. 然后再以一定的频率刷新到磁盘上.
此处频率不是事实, 而是通过`redo-log`的`checkpoint`机制来进行控制

所以缓冲池的大小影响着数据库的整体性能. 在32位系统下, 最多为3G, 但是可以通过打开操作系统的PAE选项来获得32位操作系统下最大
64G的内存支持. 推荐64位, 最多512G内存

设置缓存池大小:
> innodb_buffer_pool_size=16105127360

### 缓冲池的数据

在缓冲池中, 保存着例如: 索引页, 数据页, undo页, 插入缓冲, 自适应哈希索引, 锁信息, 数据字典信息等
索引页和数据页占了其中很大一部分

![mysql缓冲](mysql.JPG)

缓冲池可配备多个实例:
> innodb_buffer_pool_instances=1

默认为1. 设置大于一便可得到多个缓冲区

那么既然作为缓存, 那么肯定牵涉到热点数据以及LRU等一系列问题. 如何判断数据是否热点, 缓冲池如何管理数据?

### 1. LRU List, Free List 和 Flush List

#### 1.1 LRU List

和传统缓存一样, InnoDB也是通过LRU算法来对数据进行管理.
在LRU List中, 使用次数多的数据再列表的前端, 反之则在末端. 当缓冲池不能存放新的数据的时候, 首先释放末尾页

`在InnoDB中, 页的默认大小为16K`

当缓冲池往里插入新的数据的时候, 并不是直接将数据放入到首或尾, 在这里InnoDB引入了一个`midpoint`的概念.
> innodb_old_block_pct=37 (%)
在InnoDB中, 将midpoint之后的数据成为old, 之前称之为new列表, 在new列表中的数被成为**最**热点数据

当插入新的数据的时候, 会默认将数据插入到列表37%的位置. 也就是差不多3/8的位置.
为什么不讲读取到的页直接放入到LRU列表首位呢?
问题在于某些SQL操作做, 可能会使缓冲池的页被刷新出.
比如一个查询操作中, 某些页仅仅只在这次查询中需要被用到. 而如果将查询到页放到首位, 则很有可能将真正热点的数据给挤出
热点数据范围.  而当下一次需要读取热点页的时候, 又要重新从磁盘获取.
采用midpoint仅仅只是从概率上降低了这种概率, 而不是完全规避.

在InnoDB中, 还同时引入了另一个参数来管理里LRU列表
> innodb_old_blocs_time=1000 (second)

 用于表示页读取到mid位置后需要等待多久才会被加入LRU列表的热端数据. 也就是说
 当一个数据被插入之后, 需要存活多久才能去最热点数据端. 从而尽可能的使热点数据不被刷出LRU列表
当页从LRU 列表的old部分加入到new部分时, 这个操作称为 `page made young`, 而如果因为innodb_old_blocks_time的配置导致页没有
从old->new, 这个部分操作称为`page not made young`. 可以通过 `SHOW ENGINE INNODB STATUS` 来进行观察

在InnoDB1.0.x版本开始支持压缩页的功能, 如我们先前所知, 默认页大小为16K 压缩到1K,2K,4K和8K而由于页的大小发生变化, LRU了列表也有了
一些变化. 通过`unzip_LRU`来进行管理这些压缩页, 不同大小的页对应不同的unzip_LRU.
而不到16K的页申请内存过程如下:

1. 检查4KB的unzip_LRU列表, 检查是否有空闲页
2. 若有, 直接使用
3. 若无, 检查8KB的unzip_LRU列表
4. 若能够得到空闲页, 将页分成2个4KB页, 存放到4KB的unzip_LRU列表;
5. 若无法申请到空闲页, 则直接向LRU列表申请一个16KB的页, 将页分为1个8KB和2个4KB, 分别存储到对应的unzip_LRU列表中

#### 1.2 Free List

当Mysql启动的时候, LRU List 是没有任何数据的,LRU List 是管理已经读取的页. 这时候所有的页是存在于Free List中. 当下需要从缓冲池中分也是, 首先从FreeList中查找是否有
空闲页. , 若有则将该页从Free List中删除, 放入到LRU列表中. 否则从LRU old部分淘汰末尾页, 将内存空间分配给新页

#### 1.3 Flush List

如我们开头所讲的. 任何SQL操作都是优先在缓冲区或者将数据读到缓冲区进行页的更改, LRU列表中的页被修改之后, 称为脏页(Dirty Page)
这时候数据库会通过`CHECKPOINT`机制来将脏页刷回磁盘, 而Flush List中则存储着所有的脏页数据. *** 脏页同时存在于LRU List 和 Flush List当中. ***

### 2. redo-log  缓冲

redo-log 又叫重做日志. InnoDB现将重做日志缓存在缓冲池中, 再将其内容刷到磁盘日志文件.
> innodb_log_buffer_size
一般大小8M即可.因为下一秒这些数据就刷新到日志文件

日志文件更新条件:

> 1. 主线程定时每秒将redo刷到日志文件
> 2. 事务提交时
> 3. 当redo-log 缓冲池剩余空间小于1/2时

### 3. additional memory pool

这些是 缓冲池存储例如 LRU 锁 等待等信息的时候 申请内存空间的地方.

### 4. CheckPoint

之前说到了几个地方都是基于CheckPoint来进行操作. 其实CheckPoint就和游戏中的检查点一样.
试想, 由于事务数据库都采用了`Write Ahead Log` 来保证ACID中的D(Durability)持久性.
我们假设:

> 1. 缓冲池可以缓存数据库中的所有数据
> 2. 重做日志可以无限增大

缓存池既然可以存入所有数据, 那么就可以不用写入磁盘. 那么每当数据库进行事务提交的时候, redo日志页随之更新
日积月累, 这个日志将会愈加庞大. 当数据库真正需要恢复的时候, 数据库根据redo日志将数据恢复到缓冲池中, 这个代价是相当巨大的. 

现实明显不可能如此. 那么就像保存游戏一样, 只要之前的数据已经确确实实的保存到磁盘中, 游戏进度进行保存之后, 后续出现的问题我们都从最后一次的
checkpoint开始
CheckPoint解决了一下问题:

> 1. 缩短数据库的恢复时间
> 2. 缓冲池不够用时, 将脏页刷新到磁盘.
> 3. 重做日志不可用时, 刷新脏页

这里解释一下第三点, 什么是重做日志不可用?
重做日志出现不可用的情况是事务数据库系统对于重做日志的设计都是循环使用的, 并不是让其无限增大的. 重做日志可以被重用的部分是指这些重做日志已经不再需要, 即数据库宕机时
不需要这部分日志来来进行恢复. 因此这部分日志就可以被覆盖重用. 若此时重做日志还需要被使用, 那么必须强制产生CheckPoint, 将缓冲池的页至少刷新到当前重做日志的位置.

在InnoDB内部, CheckPoint有两种:

* Sharp CheckPoint
* Fuzzy CheckPoint

`Sharp CheckPoint` 发生在数据库关闭时, 将所有的脏页都刷回磁盘, 这是默认工作
`Fuzzy CheckPoint` 发生在InnoDB运行时, 只刷一部分脏页回磁盘, 否则每次都全部刷新I/O资源开销会非常巨大
在这其中可能会发生以下几种`Fuzzy CheckPoint`:

* Master Thread
* FLUSH_LRU_LIST
* Async/Sync Flush
* Dirty Page too much

`Master Thread`发生的CP 可以理解为一个定时任务, 固定的将一部分脏页刷回磁盘, 这是个异步操作
`FLUSH_LRU_LIST` 是因为InnoDB保证LRU列表中需要有差不多100个空闲页使用. `Page Cleaner`线程会异步的检查LRU中是否存在足够的可用页
而如果空间不够, 则进行FLUSH_LRU_LIST CheckPoint
`Async/Sync Flush` 是指发生在redo日志不可用的情况下, 需要强制将一些页刷回磁盘.此时脏页是从脏页列表中获取的(Flush List). 写入重写的日志的记为`redo_lsn`
而已经舒心回磁盘记为`checkpoint_lsn`
`Dirty Page too much` 则是脏页太多进行的强制刷新, 利用参数`innodb_max_dirty_pages_pct`进行控制
> innodb_max_dirty_pages_pct=80 (%)